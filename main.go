// Copyright (c) 2021 Dell Inc., or its subsidiaries. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0

package main

import (
	"fmt"
	"net/url"
	"os"
	"path"

	"github.com/dell/csm-deployment/utils/constants"
	"github.com/dell/csm-deployment/ytt"
	"github.com/labstack/echo/v4"
	"github.com/labstack/gommon/log"
	"github.com/spf13/viper"

	"github.com/dell/csm-deployment/db"
	"github.com/dell/csm-deployment/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/dell/csm-deployment/handler"
	"github.com/dell/csm-deployment/k8s"
	"github.com/dell/csm-deployment/kapp"
	"github.com/dell/csm-deployment/model"
	"github.com/dell/csm-deployment/router"
	"github.com/dell/csm-deployment/store"
	"github.com/dell/csm-deployment/utils"
	"github.com/fsnotify/fsnotify"
	echoSwagger "github.com/swaggo/echo-swagger" // echo-swagger middleware
)

// @title CSM Deployment API
// @version 1.0
// @description CSM Deployment API
// @title CSM Deployment API

// @BasePath /api/v1

// @produce	application/json
// @consumes application/json

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization

// @securityDefinitions.basic BasicAuth
// @in header
// @name Authorization

const (
	defaultConfigFile = "/etc/config/config.yaml"
)

func main() {
	scheme := utils.GetEnv("SCHEME", "https")
	hostName := utils.GetEnv("HOST", "127.0.0.1")
	port := utils.GetEnv("PORT", "8080")
	apiServerIP := utils.GetEnv("API_SERVER_IP", "127.0.0.1")
	apiServerPort := utils.GetEnv("API_SERVER_PORT", "31313")
	certDir := "/app/service-certificates"
	certFileName := "tls.crt"
	keyFileName := "tls.key"
	dbUserName := utils.GetEnv(constants.EnvDBUserName, "root")
	dbPassword := utils.GetEnv(constants.EnvDBPassword, "")

	hostNameWithPort := fmt.Sprintf("%s:%s", hostName, port)

	rt := router.New()

	utils.JWTSecret = []byte(utils.GetEnv("JWT_KEY", ""))
	if len(utils.JWTSecret) == 0 {
		rt.Logger.Fatal("jwt key is empty")
	}

	utils.CipherKey = []byte(utils.GetEnv("CIPHER_KEY", ""))
	if len(utils.CipherKey) != utils.RequiredCipherKeyLength {
		rt.Logger.Fatalf("cipher key must be %d bytes in length", utils.RequiredCipherKeyLength)
	}

	// enable viper to get properties from environment variables or default configuration file
	viper.AutomaticEnv()
	viper.SetConfigFile(defaultConfigFile)

	err := viper.ReadInConfig()
	// if unable to read configuration file, proceed in case we use environment variables
	if err != nil {
		rt.Logger.Errorf("unable to read config file: %v", err)
	}

	updateLoggingSettings := func(logger echo.Logger) {
		logLevel := viper.GetString("LOG_LEVEL")
		switch logLevel {
		case "ERROR":
			rt.Logger.SetLevel(log.ERROR)
		case "WARN":
			rt.Logger.SetLevel(log.WARN)
		case "DEBUG":
			rt.Logger.SetLevel(log.DEBUG)
		default:
			rt.Logger.SetLevel(log.INFO)
		}
	}

	updateLoggingSettings(rt.Logger)

	viper.WatchConfig()
	viper.OnConfigChange(func(e fsnotify.Event) {
		rt.Logger.Info("configuration file changed")
		updateLoggingSettings(rt.Logger)
	})

	// Update docs
	swaggerIPwithPort := fmt.Sprintf("%s:%s", apiServerIP, apiServerPort)

	docs.SwaggerInfo.Schemes = append(docs.SwaggerInfo.Schemes, scheme)
	docs.SwaggerInfo.Host = swaggerIPwithPort

	swaggerURL := url.URL{
		Scheme: scheme,
		Host:   swaggerIPwithPort,
		Path:   "swagger/doc.json",
	}

	rt.GET("/swagger/*", echoSwagger.EchoWrapHandler(echoSwagger.URL(swaggerURL.String())))

	api := rt.Group("/api/v1")

	d, err := db.New(dbUserName, dbPassword)
	if err != nil {
		rt.Logger.Fatal("Error in initializing db", err.Error())
	}

	err = db.AutoMigrate(d)
	if err != nil {
		rt.Logger.Fatal("Error in migrating the db", err.Error())
	}

	storageArrayTypesStore := store.NewStorageArrayTypeStore(d)

	db.PopulateInventory(d, storageArrayTypesStore)

	adminUsername := os.Getenv("ADMIN_USERNAME")
	if adminUsername == "" || adminUsername == "<admin-username>" {
		rt.Logger.Fatal("ADMIN_USERNAME was not provided")
	}

	adminPassword := os.Getenv("ADMIN_PASSWORD")
	if adminPassword == "" || adminPassword == "<admin-password>" {
		rt.Logger.Fatal("ADMIN_PASSWORD was not provided")
	}
	// Add a single default user
	adminUser := &model.User{
		Username: adminUsername,
		Password: adminPassword,
		Admin:    true,
	}

	hashPassword, err := adminUser.HashPassword(adminUser.Password)
	if err != nil {
		rt.Logger.Fatalf("failed to hash password", err)
	}
	adminUser.Password = hashPassword
	us := store.NewUserStore(d)

	existingUser, err := us.GetByUsername(adminUsername)
	if err != nil {
		rt.Logger.Fatalf("failed to query users", err)
	}

	if existingUser != nil {
		rt.Logger.Info("user already exists in the database")
	} else {
		rt.Logger.Info("adding new user")
		if err := us.Create(adminUser); err != nil {
			rt.Logger.Fatalf("failed to create default Admin User: %v", err)
		}
	}

	h := handler.New(us)
	h.Register(api)

	applicationStateChanges := store.NewApplicationStateChangeStore(d)

	clusters := store.NewClusterStore(d)
	hc := handler.NewClusterHandler(clusters, k8s.Client{})
	hc.Register(api)

	tasks := store.NewTaskStore(d)

	applications := store.NewApplicationStore(d)
	arrays := store.NewStorageArrayStore(d)
	modules := store.NewModuleTypeStore(d)

	dts := store.NewDriverTypeStore(d)
	dt := handler.NewDriverTypeHandler(dts)
	dt.Register(api)

	cf := store.NewConfigFileStore(d)
	cfh := handler.NewConfigFileHandler(cf)
	cfh.Register(api)

	as := handler.NewApplicationHandler(applications, tasks, clusters, applicationStateChanges, arrays, modules, dts, cf, kapp.NewClient(""), ytt.NewClient())
	as.Register(api)

	th := handler.NewTaskHandler(tasks, applications, applicationStateChanges, clusters, kapp.NewClient(""))
	th.Register(api)

	storageArrays := store.NewStorageArrayStore(d)
	sah := handler.NewStorageArrayHandler(storageArrays)
	sah.Register(api)

	mt := handler.NewModuleTypeHandler(modules)
	mt.Register(api)

	sat := handler.NewStorageArrayTypeHandler(storageArrayTypesStore)
	sat.Register(api)

	if scheme == "http" {
		rt.Logger.Fatal(rt.Start(hostNameWithPort))
	} else if scheme == "https" {
		rt.Logger.Fatal(rt.StartTLS(hostNameWithPort, path.Join(certDir, certFileName), path.Join(certDir, keyFileName)))
	} else {
		rt.Logger.Fatal("unknown scheme specified")
	}
}
